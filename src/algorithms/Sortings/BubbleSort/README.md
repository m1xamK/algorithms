# Пузырьковая сортировка (Bubble Sort)

**Пузырьковая сортировка** — это простой алгоритм сортировки, который многократно проходит через список, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока список не будет отсортирован.

## Визуализация алгоритма

![Bubble Sort](https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)

## Подробное описание алгоритма

### Основная концепция

Алгоритм работает путем многократного прохода по сортируемому массиву. На каждом проходе сравниваются соседние элементы, и если они находятся в неправильном порядке, происходит их обмен. Процесс повторяется, пока массив не будет полностью отсортирован.

### Детальный алгоритм с оптимизациями

1. **Инициализация**:
   - Начинаем с первого элемента массива (индекс 0)
   - Устанавливаем флаг обмена (swapped) в false

2. **Внешний цикл**:
   - Выполняется максимум N-1 раз (N - количество элементов)
   - После каждого прохода наибольший неотсортированный элемент "всплывает" в конец

3. **Внутренний цикл**:
   - На каждой итерации диапазон уменьшается (так как конец массива уже отсортирован)
   - Сравнивает соседние элементы и меняет их местами при необходимости
   - Если был сделан хотя бы один обмен, устанавливает флаг swapped в true

4. **Завершение**:
   - Если на полном проходе не было ни одного обмена (swapped остался false), алгоритм завершается
   - Массив считается отсортированным

### Псевдокод алгоритма

```pseudocode
procedure bubbleSort(A: list of sortable items)
    n ← length(A)
    repeat
        swapped ← false
        for i ← 1 to n-1 inclusive do
            if A[i-1] > A[i] then
                swap(A[i-1], A[i])
                swapped ← true
            end if
        end for
        n ← n - 1
    until not swapped
end procedure
```

#### Пояснение:
1. `n` - длина массива
2. `swapped` - флаг, указывающий на наличие обменов
3. Внутренний цикл проходит по несортированной части массива
4. Если элементы в неправильном порядке - они меняются местами
5. Внешний цикл повторяется, пока происходят обмены
6. После каждого прохода размер несортированной части уменьшается (`n ← n - 1`)

## Пример работы

Сортировка массива [5, 1, 4, 2, 8]:

**Первый проход**:
- (5, 1, 4, 2, 8) → (1, 5, 4, 2, 8) (5 > 1)
- (1, 5, 4, 2, 8) → (1, 4, 5, 2, 8) (5 > 4)
- (1, 4, 5, 2, 8) → (1, 4, 2, 5, 8) (5 > 2)
- (1, 4, 2, 5, 8) → (1, 4, 2, 5, 8) (5 < 8)
Результат: [1, 4, 2, 5, 8], swapped = true

**Второй проход**:
- (1, 4, 2, 5, 8) → (1, 4, 2, 5, 8) (1 < 4)
- (1, 4, 2, 5, 8) → (1, 2, 4, 5, 8) (4 > 2)
- (1, 2, 4, 5, 8) → (1, 2, 4, 5, 8) (4 < 5)
Результат: [1, 2, 4, 5, 8], swapped = true

**Третий проход**:
- Никаких обменов не происходит
- swapped остается false → алгоритм завершается

## Характеристики алгоритма

### Сложность

Случай | Лучший | Средний | Худший
------ | ------ | ------- | ------
Время  | O(n)   | O(n²)   | O(n²)
Память | O(1)   | O(1)    | O(1)

### Преимущества и недостатки

**Преимущества**:
- Простота реализации
- Устойчивость (сохраняет порядок равных элементов)
- Сортировка на месте (не требует дополнительной памяти)
- Эффективен для почти отсортированных массивов

**Недостатки**:
- Низкая производительность на больших массивах
- Много избыточных сравнений и обменов

## Вариации алгоритма

1. **Коктейльная сортировка** - проходы выполняются попеременно слева направо и справа налево
2. **Сортировка расческой** - сравнивает элементы на уменьшающемся расстоянии
3. **Оптимизация с запоминанием последнего обмена** - сокращает диапазон следующего прохода

## Сравнение с другими алгоритмами

Алгоритм | Лучший случай | Средний случай | Худший случай | Память | Устойчивость
------- | ------------ | -------------- | ------------- | ------ | -----------
Пузырьковая | O(n) | O(n²) | O(n²) | O(1) | Да
Вставками | O(n) | O(n²) | O(n²) | O(1) | Да
Выбором | O(n²) | O(n²) | O(n²) | O(1) | Нет
Быстрая | O(n log n) | O(n log n) | O(n²) | O(log n) | Нет
Слиянием | O(n log n) | O(n log n) | O(n log n) | O(n) | Да

## Области применения

1. Обучение основам алгоритмов сортировки
2. Сортировка небольших массивов
3. Системы с жесткими ограничениями памяти
4. Обработка почти отсортированных данных

## Реализация

Проект включает реализацию на C++ с использованием шаблонов для работы с разными типами данных. Алгоритм реализован с оптимизацией по флагу swapped.

```cpp
template<typename T>
void BubbleSort(std::vector<T>& array) {
    bool swapped;
    for (size_t i = 0; i < array.size() - 1; ++i) {
        swapped = false;
        for (size_t j = 0; j < array.size() - i - 1; ++j) {
            if (array[j] > array[j+1]) {
                std::swap(array[j], array[j+1]);
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}
```

# Дополнительные источники

# Сборка и запуск проекта
