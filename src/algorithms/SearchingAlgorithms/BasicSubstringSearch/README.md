# Долгосрочное ДЗ: реализация и сравнительный анализ алгоритмов поиска Рабина-Карпа, Кнута-Морриса-Пратта, с помощью конечного автомата и Бойера-Мура

**Поиск подстроки в строке** (англ. String searching algorithm) — класс алгоритмов над строками, которые позволяют найти паттерн (pattern) в тексте (text).

<a href = "https://zloyprepod.ru/21320164/mp_ddz/src/branch/dev_1/search/include/FiniteAutomatAlgo"> Алгоритм поиска с помощью конечного автомата </a>

<a href = "https://zloyprepod.ru/21320164/mp_ddz/src/branch/dev_1/search/include/KnutMorisPrattAlgo"> Алгоритм Кнута-Мориса-Пратта </a>

<a href = "https://zloyprepod.ru/21320164/mp_ddz/src/branch/dev_1/search/include/RabinCarpAlgo"> Алгоритм Рабина-Карпа </a>

<a href = "https://zloyprepod.ru/21320164/mp_ddz/src/branch/dev_1/search/include/BoierMurAlgo"> Алгоритм Бойера-Мура </a>
## Классификация алгоритмов поиска подстроки в строке

**По типу сравнения**

*Сравнение — «чёрный ящик»*

Во всех алгоритмах этого типа сравнение является «чёрным ящиком» для программиста.

Преимущества:

- позволяет использовать стандартные функции сравнения участков памяти (man *cmp(3)), которые, зачастую, оптимизированы под конкретное железо.

Недостатки:

- не выдается точка, в которой произошло несовпадение.

**По порядку сравнения паттерна в тексте**

*Прямой*

Преимущества:
- отсутствие регрессии на «плохих» данных.

Недостатки:
- не самая хорошая средняя асимптотическая сложность.

*Обратный*

Паттерн движется по тексту слева направо, но сравнение подстрок происходит справа налево.

Преимущества:
- при несовпадении позволяет перемещать паттерн по строке сразу на несколько символов.

Недостатки:
- производительность сильно зависит от данных.

*Сравнение в необычном порядке*

Специфические алгоритмы, основанные, как правило, на некоторых эмпирических наблюдениях над словарём.

**По количеству поисковых шаблонов**

Сколько поисковых шаблонов может обработать алгоритм за один раз.

- один шаблон (англ. single pattern algorithms)
- конечное количество шаблонов (англ. finite set of patterns)
- бесконечное количество шаблонов (англ. infinite number of patterns) (см. Теория формальных языков)

**По необходимости препроцессинга текста**

Виды препроцессинга:
- Префикс-функция
- Z-функция
- Бор
- Суффиксный массив

Алгоритмы, использующие препроцессинг — одни из самых быстрых в этом классе.

## Выбор алгоритмов для задания

В процессе работы над ДЗ_07 я пришел к выводу, что именно эти алгоритмы обладают оптимальным сочетанием между вычислительной сложностью, понятностью и быстротой реализации.

## Сравнение теоретической сложности алгоритмов

|А|=a — мощность алфавита

|text|=n — длина текста

|pattern|=m — длина паттерна

a — размер ответа(кол-во пар)

s — суммарная длина всех паттернов

Название | Среднее | Худшее | Препроцессинг | Дополнительная память | Кол-во поисковых шаблонов | Порядок сравнения | Описание
-------- | ------- | ------ | ------------- | --------------------- | ------------------------- | ----------------- | --------
Наивный алгоритм (Brute Force algorithm) | O(m⋅(n−m)) | O(n<sup>2</sup>) |  | O(1) | Single | Прямой | Сравнение — «чёрный ящик». Если m достаточно мало по сравнению с n, то асимптотика будет близкой к O(n), что позволяет использовать его на практике в случаях, когда паттерн много меньше текста (например, Ctrl+F в браузерах)
Поиск подстроки в строке с помощью Z-функции | O(n) | O(n) | O(m+n) | O(p) | Single | Прямой |
Алгоритм Рабина-Карпа | O(m+n) | O(mn) | O(m) | O(1) | Single / Finite | Прямой | Данный алгоритм использует хэширование, что снижает скорость в среднем. Можно модифицировать для поиска нескольких паттернов 
Алгоритм Кнута-Морриса-Пратта | O(m+n) | O(m+n) | O(m) | O(m) | Single | Прямой | Использует префикс-функцию
Алгоритм Колусси (Colussi algorithm) | O(n) | O(n) | O(m) | O(m) | Single | Прямой / Обратный | Оптимизация Алгоритма Кнута-Морриса-Пратта использует как прямой, так и обратный обход
Алгоритм Ахо-Корасик (Aho–Corasick string matching algorithm) | O(s+n+a) | O(n) | O(s) | O(sa) | Finite | Прямой | Строит конечный автомат. Можно хранить таблицу переходов как индексный массив (array), а можно как Красно-черное дерево. В последнем случае уменьшится расход памяти, но ухудшится асимптотика
Алгоритм Shift-Or | O(n) | O(n⋅m/w), w — размер машинного слова | O(m+а) | O(m+а) | Single | Прямой | Использует тот факт, что в современных процессорах битовые сдвиг и или являются атомарными. Эффективен, если m⩽w. Иначе деградирует и по памяти, и по сложности
Алгоритм Бойера-Мура (Boyer-Moore algorithm) | O(n) | O(mn) | O(m+а) | O(m+а) | Single | Обратный | Считается наиболее быстрым из алгоритмов общего назначения. Использует эвристики. Существует большое количество оптимизаций
Поиск подстроки в строке с помощью суффиксного массива (Suffix array) | O(mlog(n)) | O(mlog(n)) | O(n) | O(n) | Single | Прямой | Использует Суффиксный массив. Если использовать Largest common prefix (lcp), то можно уменьшить асимптотику до O(m+log(n)). Суффиксный массив можно строить стандартными способами или алгоритмом Карккайнена-Сандерса. Асимптотика приведена для построения суффиксного массива с помощью алгоритма Карккайнена-Сандерса
Поиск подстроки в строке с помощью суффиксного дерева (Suffix tree) | O(m) | O(m) | O(n) | O(n) | Single | Прямой | Позволяет выполнять поиск подстроки в строке за линейное время
Алгоритм Апостолико-Крочемора (Apostolico-Crochemore algorithm) | O(n) | O(n) | O(m) | O(m) | Single | Прямой | В худшем случае выполнит 1.5n сравнений.


# Анализ производительности реализации на языке с++

Проведем результаты времени поиска на примере романа Война и Мир (примерно 2 966 547 символов)

*Сравнение происходит только для первых двух алгоритмов в силу проблем с кодировкой романа*

длина подстроки\время работы | Рабин-Карп | Кнут-Моррис-Пратт | количество совпадений
-----------------------------|------------|-------------------|----------------------
"War and Peace" (13 символов) | 0.058199s | 0.049292s | 33
"The robbery and looting go on. There is a gang of thieves in our district that would need strong guards to arrest it. 11 October." (129 символов) | 0.059039s | 0.0474s | 1
"movement" (8 символов) | 0.064818s | 0.050386s | 336
"The specialized historian, describing the campaign of the year thirteen, or the restoration of the Bourbons, says directly that these events were produced by the will of Alexander. But the general historian Gervinus, disproving this view of the specialized historian, aims to show that the campaign of the year thirteen and the restoration of the Bourbons had as their causes, besides the will of Alexander, the activity of Stein, Metternich, Mme de Sta&#235;l, Talleyrand, Fichte, Chateaubriand, and others. The historian has obviously broken down the power of Alexander into its components: Talleyrand, Chateaubriand, and so on; the sum of these components, that is, the mutual influence on each other of Chateaubriand, Talleyrand, Mme de Sta&#235;l, and others, obviously does not equal the whole resultant, that is, the phenomenon that millions of Frenchmen submitted to the Bourbons. From the fact that Chateaubriand, Mme de Sta&#235;l, and others said such-and-such words to each other, there follows only their relations among themselves, not the submission of millions. And therefore, in order to explain in what way the submission of millions followed from their relations, that is, how from components equal to one A there followed a resultant equal to a thousand times A, the historian must necessarily allow again for the same force of the power which he denies, recognizing it as the result of forces, that is, he must allow for the unexplained force acting upon the composite. This is what general historians do. And consequently they contradict not only the specialized historians, but also themselves." (1617 символов) | 0.059125s | 0.047611s | 1

Заметим, что на данном этапе однозначно лидирует алгоритм Кнута-Морриса-Пратта

Сгенерируем большое количество повторяющихся строк и проведем испытания на них (порядка 107049600 символов)

длина подстроки\время работы | Рабин-Карп | Кнут-Моррис-Пратт | конечный автомат | Бойер-Мур | количество совпадений
-----------------------------|------------|-------------------|------------------|----------|-----------------------
"abcde" (5 символов) | 1.96297s | 1.78322s | 1.17437s | 0.697919s | 2019600
"abcdefghijklmanopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" (53 символов) | 3.23458s | 2.73332s | 1.26814s | 1.27158s | 2019600
"abcdefghijklmanopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" x 4 (212 символов) | 7.00196s | 2.7473s | 1.14837s | 5.43688s | 2019600
"abcdefghijklmanopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" x 20 (1060 символов) | 28.2672s | 2.74396s | 1.30098s | 25.5049s | 2019581

Заметим, что на повторяющихся данных алгоритм Кнута-Морриса-Пратта ведет себя стабильно за счет префикс-таблицы, в то время как алгоритм Рабина-Карпа сильно падает с увеличением данных.
Кроме того, алгоритм поиска с помощью коечного автомата тратит много времени на построение автомата, но сам поиск затем выполняет оч быстро.

# Вывод

В результате сравнения на сравнительно больших данных аутсайдером оказался алгоритм Рабина-Карпа (очевидно), а также алгоритм Бойера-Мура, который, однако, эффективнее при поиске малых фрагментов. Явным лидером оказался алгоритм с конечным автоматом, который во всех случах работает очень шустро. Не так далеко за ним идет алгоритм Кнута-Мориса-Пратта, который хоть и работает чуть хуже, гораздо понятнее в плане идеи и реализации. Таким образом, Кнут-Морис-Пратт является достаточно универсаьным алгоритмом, в то время как поиск с помощью конечного автомата требует время на построение самого автомата, что, возможно, не совсем эффективно на малых данных, но крайне эффективно на больших. Поэтому единственный верный ответ на вопрос, кто лучше - в зависимости от поставленных задач. На малых данных, особенно при малой подстроке, вполне неплохо себя показывает и брутфорс, зато при действительно больших объемах из представленных алгоритмов самый эффективный - конечный автомат.