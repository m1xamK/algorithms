# Поиск подстрок с помощью конечного автомата

## Теоритетические сведения

Коне́чный автома́т (**КА**) в теории алгоритмов — математическая абстракция, модель дискретного устройства, имеющего один вход, один выход и в каждый момент времени находящегося в одном состоянии из множества возможных. Является частным случаем абстрактного дискретного автомата, число возможных внутренних состояний которого конечно.

При работе на вход **КА** последовательно поступают входные воздействия, а на выходе КА формирует выходные сигналы. Обычно под входными воздействиями принимают подачу на вход автомата символов одного алфавита, а на выход КА в процессе работы выдаёт символы в общем случае другого, возможно даже не пересекающегося со входным, алфавита.

Помимо конечных автоматов существуют и бесконечные дискретные автоматы — автоматы с бесконечным числом внутренних состояний.

Переход из одного внутреннего состояния **КА** в другое может происходить не только от внешнего воздействия, но и самопроизвольно.

Различают детерминированные **КА** — автоматы, в которых следующее состояние однозначно определяется текущим состоянием и входным символом и выход зависит только от текущего состояния и текущего входа, и недетерминированные КА, следующее состояние у которых в общем случае не определено и, соответственно, не определён выходной сигнал. Если переход в последующие состояния происходит с некоторыми вероятностями, то такой **КА** называют вероятностным **КА**.

Примерами физической реализации **КА** могут служить любые цифровые системы, например, компьютеры или некоторые логические узлы компьютеров с памятью — триггеры и другие устройства. Комбинационная последовательная логика не может являться **КА**, так как не имеет внутренних состояний (не имеет памяти).

---

## Почему это эффективно?

Конечные автоматы очень эффективны, потому что они проверяют каждый символ ровно один раз, затрачивая константное время на каждый символ. В итоге время проверки всей строки равно O(n), где n — длина текстовой строки.

Но время предварительной обработки, т. е. время, необходимое для построения конечного автомата, может быть большим, если паттерн длинный, так как сложность построения автомата О(n³).

Помимо поиска конечные автоматы обычно используются для организации и представления потока выполнения чего-либо. Это особенно полезно при реализации ИИ в играх. Например, для написания «мозга» врага: каждое состояние представляет собой какое-то действие (напасть, уклониться и т. д.).

---

## Пример **КА**

Прежде чем мы обсудить программную реализацию конечного автомата, давайте взглянем на следующий конечный автомат для шаблона ACACAGA.

![Alt-текст](/images/autometa1.png)
![Alt-текст](/images/autometa2.png)

Приведенные выше диаграммы представляют собой графическое и табличное представления паттерна ACACAGA.

Количество состояний в конечном автомате будет `M+1`, где `М` - длина шаблона. 

**Главное** в построении конечного автомата — получить следующее состояние из текущего состояния для каждого возможного символа. 
Имея символ `x` и состояние `k`, мы можем получить следующее состояние, рассматривая строку `pat[0..k-1]x`, которая представляет собой конкатенацию символов шаблона `pat[0], pat[1] … pat[ k-1]` и символ `x`. 

Идея состоит в том, чтобы получить длину самого длинного префикса данного шаблона так, чтобы префикс также был суффиксом `pat[0..k-1]x`. Значение длины дает нам следующее состояние. 

Например, давайте посмотрим, как получить следующее состояние из текущего состояния 5 и символа «C» на приведенной выше диаграмме. Нам нужно рассмотреть строку	`pat[0..4]C`, которая является «ACACAC». Длина самого длинного префикса шаблона, в котором префикс является суффиксом «ACACAC», равна 4 («ACAC»). 

---

## Реализация

### Для построение автомата необходимо:
1. Реализовать функцию получения следующего состояния автомата `getNextState`.
2. С помощью функции `getNextState` построить таблицу переходов `TF` (функция `computeTF`).


### Функция `getNextState`
Используется для получения следующего состояния автомата на основе текущего состояния и следующего символа в тексте.

Функция `getNextState` принимает два аргумента: текущее состояние автомата (`currentState`) и следующий символ в тексте (`nextChar`). Она возвращает следующее состояние автомата (`nextState`).

#### Алгоритм `getNextState` работает следующим образом: 

1. Если следующий символ в тексте (`nextChar`) совпадает с символом, соответствующим переходу из текущего состояния (`currentState`), то мы переходим в следующее состояние, соответствующее этому переходу.

2. Если следующий символ в тексте (`nextChar`) не совпадает с символом, соответствующим переходу из текущего состояния (`currentState`), то мы должны "прыгнуть" на другое состояние, которое может быть достигнуто из текущего состояния путем нескольких переходов. Для этого мы используем таблицу переходов (`transition table`), которая хранит информацию о том, какие переходы возможны из каждого состояния и какие символы соответствуют этим переходам. Мы ищем ближайшее состояние, которое может быть достигнуто из текущего состояния путем нескольких переходов и которое имеет переход, соответствующий следующему символу в тексте (`nextChar`).

3. Если такое состояние не найдено, то мы переходим в состояние, которое соответствует начальному состоянию автомата. Это происходит, когда мы достигаем конца текста и не находим в нем образца.

Таким образом, функция `getNextState` используется для определения следующего состояния автомата на основе текущего состояния и следующего символа в тексте. Это позволяет алгоритму поиска образца с использованием конечного автомата эффективно искать все вхождения образца в текст.

---

### Функция `computeTF` #
Используется для построения таблицы переходов (`TF table`), которая представляет конечный автомат для заданного образца (`pat`). 
#### Алгоритм работы функции можно описать следующим образом:

1. Функция принимает на вход образец (`pat`) и его длину (`M`), а также двумерный массив `TF`, который будет использоваться для хранения таблицы переходов.

2. Запускаем вложенные циклы: первый цикл перебирает все состояния конечного автомата (от 0 до `patLen`), а второй цикл перебирает все символы в образце (от 0 до `NO_OF_CHARS`).

3. Для каждой пары состояние-символ вызываем функцию `getNextState`, которая определяет следующее состояние конечного автомата в зависимости от текущего состояния и символа в строке.

4. Записываем полученное значение в соответствующую ячейку массива `TF`. Таким образом, по окончании работы функции в массиве `TF` будет храниться таблица переходов для заданного образца.

Таким образом, функция `computeTF` используется для построения конечного автомата (Finite Automata) для заданного образца, что позволяет эффективно искать все вхождения образца в другой строке.

---
### Функция `search`

Осуществляет поиск образца `pat` в строке `txt` с использованием таблицы переходов `TF`, которая строится с помощью функции `computeTF`.

#### Алгоритм работы функции search:

1. Вычисляем длину образца `pat` и длину строки `txt`.

2. Создаем двумерный массив `TF` размером `(patLen + 1) x NO_OF_CHARS`, где `patLen` - длина образца, а `NO_OF_CHARS` - количество возможных символов в строке.

3. Вызываем функцию `computeTF`, которая заполняет массив `TF`.

4. Инициализируем переменную `state` значением 0.

5. Запускаем цикл по символам строки `txt` от 0 до `txtLen - 1`.

6. Внутри цикла переходим в новое состояние `state`, используя таблицу переходов `TF[state][txt[i]]`, где i - текущий индекс символа в строке txt.

7. Если новое состояние `state` равно длине образца `pat`, то мы нашли вхождение образца в строку. Выводим индекс, где начинается вхождение, используя формулу `i - patLen + 1`.

8. Повторяем шаги 6-7 для всех символов строки `txt`.

Заметим, что алгоритм является линейным относительно длины строки `txt` и образца `pat`, так как каждый символ строки `txt` проходится только один раз, а таблица переходов пройдена только один раз в функции `computeTF`. Это делает алгоритм эффективным для поиска образца в больших текстах.